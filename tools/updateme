#!/bin/bash

# "updateme" script.

#  Copyright (c) 2010-2011 Wind River Systems, Inc.

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

#  This script must be run from inside a Linux source directory

usage()
{
cat << EOF

 updateme [--no-strict] [-D<var>=<value>] [--branch ${kbranch}] [--feature <feature name>] \
           ${ARCH} ${MACHINE} [features or directories]

      --no-strict: do not error if a passed feature cannot be found
      --branch:    the branch to process for the machine definition. If not
                   passed, the current branch will be used
      --feature:   apply a feature named $feature to the machine description.
                   The feature must be found in ${WORKDIR}
      -D:          define <var> to <value> which will be available to sub scripts 
       ${ARCH}:    The kernel architecture of the machine. This is used to locate
                   default options/configuration.
       ${MACHINE}: The name of the machine. This is used to locate the machine
                   description created via 'creatme'
       [features or directories]: A space separated list of features or directories
                                  to search for features. Any argument that is a
                                  directory is added to the search dirs. Any argument
                                  that is not a directory is considered a feature
                                  name that should be added (similar to --feature,
                                  which is the preferred method).

EOF
}

if [ -d "wrs" ]; then
    meta_dir=wrs
else
    meta_dir=meta
fi

if [ -z "$1" ]; then
	usage
	exit
fi

while [ $# -gt 0 ]; do
	case "$1" in
	    --help)
		usage
		exit
	        ;;
	    --feature)
		cmd_line_features="$cmd_line_features $2"
		shift
		;;
	    --branch)
		cmd_line_branch="$2"
		shift
		;;
            # depreciated. do not use
	    --features)
		cmd_line_features="$2"
		shift
		;;
            -D*|--D*)
                if [ "$1" == "-D" ] || [ "$1" == "--D" ]; then
                    x=$2; shift;
		else
                    x=`echo $1 | sed s%^-*D%%`
                fi
		defines="$defines $x" ;;
            -I*|--I*)
                if [ "$1" == "-I" ] || [ "$1" == "--I" ]; then
                    x=$2; shift;
		else
                    x=`echo $1 | sed s%^-*I%%`
                fi
		includes="$includes -I$x" ;;
	    --no-strict)
		nostrict=t
		;;
	    --force)
		force=t
		;;
	    -v) verbose=t
		;;
	    *) break
		;;
	esac
	shift
done

# arg1 is the ARCH
arch=$1
# arg2 is the machine
machine=$2
shift
shift

# everything else is features
command_line_dirs=$@

# flags. if no-strict wasn't passed on the command line,
# enable strict processing.
if [ -z "$nostrict" ]; then
	strict=t
fi

if [ -z "$cmd_line_branch" ]; then
    CURRENT=`git branch |grep \*|sed 's/^\* //'`
else
    CURRENT=$cmd_line_branch
fi

##
## create variables for use in scripts
##
if [ -n "$defines" ]; then
    vars=$(echo $defines | sed 's/,/ /g')
    for v in "$vars"; do
        # eval makes it available for this script
        eval $v
	# echo makes it available for other scripts
	dump_vars=$(echo "$dump_vars"; echo export $v)
    done
fi

gen_dirs() {
	top_dir=$1

	for dir in $includes; do
	    x=`echo $dir | sed s%^-*I%%`
	    if [ -d "$x" ]; then
		search_dirs="$search_dirs $x"
	    fi
	done

	potential=`find $top_dir -maxdepth 3 -type d -name kernel*cache`
	for dir in $potential; do
	    search_dirs="$search_dirs $dir"
	    includes="$includes -I $dir"
	done
}

# searches for extra files to build
find_features() {
	dirs=$@

	for d in $dirs; do
	    potential=`find $d -maxdepth 1 -type f -name *.scc`
	    # we should *not* auto-add a .scc file that defines
	    # KMACHINE, etc. These are leaf nodes that should be 
	    # explicitly requested.
	    for p in $potential; do
		grep -q KMACHINE $p
		if [ $? -ne 0 ]; then
		    extra_features="$extra_features $p"
		else
		    cp $p $meta_dir/cfg/scratch/obj
		fi
	    done
	done
}

# searches for extra configs to include, only if they haven't
# been pulled into a .scc file already
find_configs() {
	dirs=$@
	
	# defconfigs should be found first, so fragments can tweak
	# settings
	for d in $dirs; do
	    potential=`find $d -maxdepth 1 -type f -name defconfig`
	    scc_files=`find $d -maxdepth 1 -type f -name *.scc` 
	    for c in $potential; do
		b=`basename $c`
		f=`readlink -f $c`
	    	# check to see if a .scc file already includes the fragement
		if [ -n "$scc_files" ]; then
			grep $b $d/*.scc -q
			if [ $? -ne 0 ]; then
		    		extra_cfgs="$extra_cfgs $f"
			fi
		else
			extra_cfgs="$extra_cfgs $f"
		fi
	    done
	done

	for d in $dirs; do
	    potential=`find $d -maxdepth 1 -type f -name *.cfg`
	    scc_files=`find $d -maxdepth 1 -type f -name *.scc` 
	    for c in $potential; do
		b=`basename $c`
		f=`readlink -f $c`
	    	# check to see if a .scc file already includes the fragement
		if [ -n "$scc_files" ]; then
			grep $b $d/* -q
			if [ $? -ne 0 ]; then
		    		extra_cfgs="$extra_cfgs $f"
			fi
		else
			extra_cfgs="$extra_cfgs $f"
		fi
	    done
	done
}

# searches for extra patches to include, only if they haven't
# been pulled into a .scc file already
find_patches() {
	dirs=$@
	
	for d in $dirs; do
	    potential=`find $d -maxdepth 1 -type f -name *.patch`
	    potential="$potential `find $d -maxdepth 1 -type f -name *.diff`"
	    potential="$potential `find $d -maxdepth 1 -type f -name *.mbox`"
	    for c in $potential; do
		b=`basename $c`
		f=`readlink -f $c`
	    	# check to see if a .scc file already includes the patch
		grep $b $d/* -q
		if [ $? -ne 0 ]; then
		    extra_patches="$extra_patches $f"
		fi
	    done
	done
}

do_compile_prep() {
	top_dir=$1

	mkdir -p $meta_dir/cfg/scratch/obj
	(cd $meta_dir/cfg/scratch/obj
	    rm -f *.sco
	)

	# updates 'includes' and 'search_dirs'
	gen_dirs $top_dir
	includes="-I $top_dir $includes"
	search_dirs="$top_dir $search_dirs"
}

# note: this will be removed in future updates, once all descriptions
#       and trees no longer use scc_leaf
search_includes_for_branch()
{
	target=$1
	parent=$2
	found_scc=

	# Note the space and EOL anchor.  We want to find the SCC file where
	# CURRENT is on the far RHS, i.e. the one that created the branch,
	# and NOT some SCC file that uses the branch as a starting point.
	# There is an alternate target, where all _ have been replaced by -
	alt_target=`echo $target | sed 's/_/.*/g'`
	alt_parent=`echo $parent | sed 's/_/.*/g' | sed 's/-/.*/g'`
	SCC_LIST=`find $search_dirs -name '*.scc' | xargs grep -l -e 'scc_leaf.* '$target'$' -e 'scc_leaf.* '$alt_target'$' | sort | uniq`
	for s in $SCC_LIST; do 
		found=`grep -E "scc_leaf.*$parent" $s`
    		if [ -n "$found" ]; then
			found_scc="$found_scc $s"
		else
		    found=`grep -E "scc_leaf.*$alt_parent" $s`
		    if [ -n "$found" ]; then
			found_scc="$found_scc $s"
		    fi
    		fi
	done

	echo "$found_scc"
}

search_includes_for_defines()
{
	defines=$1	
	found_scc=

	if [ -n "$defines" ]; then
		define_tgt1=`echo $defines | cut -d: -f1`
		define_tgt2=`echo $defines | cut -d: -f2`
		define_tgt3=`echo $defines | cut -d: -f3`
	fi

	sccs_that_define=`find $search_dirs -name '*.scc' \
                                | xargs grep -l -e 'define.*' | sort | uniq`
	for scc in $sccs_that_define; do
		score=0
		max_score=0
		for tgt in $define_tgt1 $define_tgt2 $define_tgt3; do
			if [ -n "$tgt" ]; then
				max_score=`expr $max_score + 1`
				f=`grep -l -e 'define.* '$tgt'$' $scc`
				if [ -n "$f" ]; then
			    	    score=`expr $score + 1`
				fi
			fi
		done

		if [ $score -eq $max_score ]; then
			found_scc="$found_scc $scc"
		fi
	done

	echo "$found_scc"
}

do_update() {
	branch=$1
	top_dir=$2

	# we need to condition the branch. If it is in the form that
	# uses / for inheritance, special processing needs to be done.
	echo $branch | grep -q "/"
	if [ $? -eq 0 ]; then
	    # remove trailing "/base" that won't be in the .scc files themselves
	    tgt=`echo $branch | sed 's%/base$%%'`
	    # the parent branch is the second to last, i.e. standard/common_pc
	    # so we can reverse everything and take the second field
	    parent=`echo $tgt | rev | cut -d'/' -f2 | rev`
	    short_branchname=`echo $tgt | rev | cut -d'/' -f1 | rev`
	else
	    # in dashed naming, it's $machine-$parent
	    parent=`echo $branch | rev | cut -d'-' -f1 | rev`
	    short_branchname=$branch
	fi

	# KDESC is MACHINE:KERNEL_TYPE
	if [ -n "$KDESC" ]; then
	    kmachine=`echo $KDESC | cut -d: -f1`
	    ktype=`echo $KDESC | cut -d: -f2`
	else
	    kmachine=$short_branchname
	    ktype=$parent
	fi
	
	ktgt=$kmachine-$ktype

	top_tgt=`search_includes_for_branch $short_branchname $parent`
	# refine the search to the $machine if we have more than one hit
	for tgt in $top_tgt; do
	    case `basename $tgt` in
		$machine*) best_match=$tgt ;;
                *) other_match=$tgt ;;                
	    esac
	done
	top_tgt=$best_match
	if [ -z $top_tgt ]; then
	    top_tgt=$other_match
	fi

	# the target could not be found based on the branch, try a secondary
	# search based on defines
	if [ -z "$top_tgt" ]; then
	    top_tgt=`search_includes_for_defines "$KDESC"`
	fi

        # if there isn't a target .. we'll need to create one
	if [ -z "$top_tgt" ]; then
	    target=${ktgt%-*}

	    # we need to generate a baseline configuration
	    (
		old_pwd=`pwd`
		cd $meta_dir/cfg/scratch/obj
		echo "# auto generated BSP file" > $ktgt.scc

		echo "define KMACHINE $kmachine" >> $ktgt.scc
		echo "define KTYPE $ktype" >> $ktgt.scc
		echo "define KARCH $arch" >> $ktgt.scc

		if [ -n "$KDESC" ]; then
		    echo "branch $branch" >> $ktgt.scc
		else
		    echo "" >> $ktgt.scc
		    echo "include ktypes/$ktype" >> $ktgt.scc
		    echo "branch $short_branchname" >> $ktgt.scc
		fi

		# this is a placeholder for common functionality .. i.e. the ktype, but
		# it is not typically included by default.
		cd $old_pwd
		mkdir -p $meta_dir/cfg/kernel-cache/ktypes/$ktype

		echo "# autogenerated $ktype kernel" >> $meta_dir/cfg/kernel-cache/ktypes/$ktype/$ktype.scc
		if [ "$ktype" != "$kbranch" ]; then
		    echo "branch $ktype" >> $meta_dir/cfg/kernel-cache/ktypes/$ktype/$ktype.scc
		fi
	    )

	    top_tgt=$meta_dir/cfg/scratch/obj/$ktgt.scc
	fi

	# store the name of the top level .scc file for future reference
	echo $top_tgt > $meta_dir/top_tgt

	# this builds and applies the meta-series
	( cd $meta_dir/cfg/scratch/obj
	    if [ -n "$extra_cfgs" ]; then
		for c in $extra_cfgs; do
		    b=`basename $c`
		    cp $c .
		    echo "kconf required $b" >> auto_feat.scc
		done
	    
		extra_features="$extra_features auto_feat.scc"
	    fi

	    if [ -n "$extra_patches" ]; then
		for c in $extra_patches; do
		    b=`basename $c`
		    cp $c .
		    echo "patch $b" >> auto_feat.scc
		done
	    
		echo "$extra_features" | grep -q auto_feat.scc
		if [ $? -ne 0 ]; then
		    extra_features="$extra_features auto_feat.scc"
		fi
	    fi

	    scc -o $ktgt $includes $top_tgt $extra_features $addon_features

	    if [ -e "$ktgt" ]; then
		bash ./$ktgt > ../$ktgt-meta
	    else
		echo "ERROR. Could not find an excutable target for $branch"
	    fi
	)
}

process_args()
{
	args=$@

	for a in $args; do
		if [ -d $a ]; then
			feature_dirs="$feature_dirs $a"
		else
			features_to_find="$features_to_find $a"	
		fi
	done
}


_strip_ext()
{
    # this isn't quite "basename" we want the full
    # path, just no extension, i.e. without basename's
    # habit of removing the last element no matter what
    local name=$1
    local ext=$2

    if [ -n "$ext" ]; then
	echo "$name" | sed "s%$ext$%%"
    else
	echo $name
    fi
}

do_addon_features()
{
	feats=$@

	for f in $feats; do
	        found_feat=
		for d in $search_dirs; do
		        search_feat=`_strip_ext $f .scc`
			potential=`find $d | grep -E ".*$search_feat\.scc"`
			if [ -n "$potential" ]; then
				addon_features="$addon_features $potential"
				found_feat="$potential"
			else
				if [ -e "$d/$f" ]; then
				        # if it is a directory, only pass the dir name.
					if [ -d "$d/$f" ]; then
						addon_features="$addon_features $f"
						found_feat="$f"
					else
						addon_features="$addon_features $d/$f"
						found_feat="$d/$f"
					fi
				fi
			fi
		done
		if [ -n "$strict" ] && [ -z "$found_feat" ]; then
			echo "WARNING: addon feature \"$search_feat\" was not found"
			missing_feat=t
		fi
	done

	if [ -n "$missing_feat" ]; then
		echo "ERROR: required features were not found. aborting"
		exit 1
	fi
}


# $PWD is the Linux src directory
linux_src_dir=`pwd`

do_compile_prep $linux_src_dir

# sorts the command line options and returns "feature_dirs" and 
# "features_to_find"
process_args $command_line_dirs

find_features $feature_dirs
find_configs $feature_dirs
find_patches $feature_dirs

do_addon_features $cmd_line_features $features_to_find

do_update $CURRENT $linux_src_dir
